# 6. 동시성 & 트랜잭션 시나리오

## 1. 핵심 동시성 문제: 좌석 중복 예약

### 시나리오
-   사용자 A와 사용자 B가 거의 동시에 `1번 좌석`에 대한 예약(`POST /api/reservations`)을 요청합니다.
-   두 요청이 서로 다른 서버 인스턴스로 전달됩니다.

### 해결 전략: 분산 락 (Distributed Lock)
-   좌석 예약 로직 시작 시, Redis를 이용해 해당 좌석에 대한 **분산 락**을 획득 시도합니다.
-   **락 키(Lock Key):** `lock:seat:{scheduleId}:{seatNumber}` (예: `lock:seat:1:1`)
-   **획득 로직:**
    1.  `SET lock:seat:1:1 {userId} NX PX 3000` 커맨드를 실행합니다.
        -   `NX`: 키가 존재하지 않을 때만 SET을 수행 (Atomic 연산).
        -   `PX 3000`: 3초의 TTL(Time-To-Live)을 설정하여 락을 획득한 스레드가 비정상 종료되어도 락이 자동으로 해제되도록 보장 (Safety Latch).
    2.  락 획득에 성공한 서버(e.g., 사용자 A의 요청 처리)만 비즈니스 로직(DB에 좌석 상태 변경)을 계속 진행합니다.
    3.  락 획득에 실패한 서버(e.g., 사용자 B의 요청 처리)는 즉시 `409 Conflict` 에러를 반환합니다.
    4.  비즈니스 로직이 성공적으로 끝나면, 획득했던 락을 명시적으로 해제(`DEL lock:seat:1:1`)합니다.

### 트랜잭션 범위
-   락 획득 후, `SEATS` 테이블의 상태를 `AVAILABLE`에서 `RESERVED`로 변경하고 `RESERVATIONS` 테이블에 `PENDING` 상태의 레코드를 삽입하는 과정은 단일 **DB 트랜잭션**으로 묶여야 합니다.

## 2. 임시 배정 좌석의 자동 만료 처리

### 시나리오
-   사용자 C가 `2번 좌석`을 임시 배정받았으나, 5분 내에 결제하지 않았습니다.
-   해당 좌석은 다른 사용자들이 예약할 수 있도록 `AVAILABLE` 상태로 돌아가야 합니다.

### 해결 전략: 스케줄러 (Scheduler)
-   애플리케이션 내 스케줄러가 1분마다 주기적으로 동작합니다.
-   **스케줄러 로직:**
    1.  `RESERVATIONS` 테이블에서 `status`가 `PENDING`이고 `expires_at`이 현재 시간보다 이전인 모든 예약 건을 조회합니다.
    2.  조회된 각 예약 건에 대해 다음을 수행합니다.
        -   해당 예약의 `status`를 `EXPIRED`로 변경합니다.
        -   연관된 `SEATS` 테이블의 `status`를 `AVAILABLE`로 변경합니다.
    3.  이 과정 역시 **DB 트랜잭션** 내에서 처리되어 데이터 일관성을 보장합니다.
