<aside>
👑 명예의 전당

</aside>

- 유재현님
  - 마일스톤

    [콘서트 예매 서비스 • dbwogus94](https://github.com/users/dbwogus94/projects/3)

  - 시퀀스 다이어그램

    [시퀀스 다이어그램](https://www.notion.so/1198dbc2842280079f14d8153e4ff406?pvs=21)

  - 대기열 설계

    ‣

  - 리드미
  - PR

<aside>
🎯 지난 주차 Summary

</aside>

### 설계 문서의 중요성

<aside>
🧑‍💻 나는 코드 짜는 게 더 즐거워요…

</aside>

서버 구축 1주차에서 주요하게 다뤘던 부분은 **`분석`** 과 **`설계`** 의 영역입니다.

실제 현업에서 업무를 함께하다 보면 두 영역을 간과하고 IDE 와 노는 게 더 좋다는 개발자 분들을 뵐 수가 있습니다. 하지만 이 경우, 대부분 숙련된 도메인 전문가가 아닌 이상은 요구 사항의 본질적인 기능, 유기적인 관계 등을 제대로 정의하지 못한 채 개발을 진행하고 후에 그 업보를 받아 **“아 오늘도 야근이야”** 라는 말과 함께 과중하지 않았던 업무의 양임에도 회사의 업무가 과도하다고 욕하는 경우를 볼 수 있었죠.

소프트웨어 개발에서의 설계는 아래와 같은 중요성을 갖는다고 생각합니다.

- 최상의 사용자 경험과 고객 가치를 전달하기 위한 “소통”의 일환
- 서로 다른 배경 지식의 협업자들과도 원활하게 소통할 수 있도록 하는 도구
- 올바른 요구 사항의 분석, 변화에 대한 의사 결정의 히스토리

위 사항들을 올바르게 전달하고 보관할 수 있다면 형태 ( UML, 시퀀스 다이어그램, FLOW CHART 등 ) 는 크게 중요하지 않다고 생각하는 편입니다. 다만 이미 표준화가 되어 소통을 좀 더 원활하게 할 수 있는 도구이기 떄문에 이러한 기법을 익히고 표현하는 연습을 해보시는 것을 추천드립니다.

<aside>
⛵ **이번 챕터 목표**

</aside>

- **아키텍처와 테스트에 집중하며, 시나리오 기반 서버 애플리케이션 구축**
- 아키텍처와 테스트 코드 작성에 집중하며, 견고하고 유연한 서버 개발을 지향합니다.

<aside>
🚩 **What to do: 이번 챕터에 해야 할 것. 이것만 집중하세요!**

</aside>

### 4. API Spec Documentation

<aside>
💡 우리는 적절한 API 명세 문서를 노출하고 MockAPI 를 제공해 생산성을 증대시켜야 합니다.

</aside>

**API 문서만 보고도 이해할 수 있게!**

- **OAS** (Open API Specification) , **AsyncAPI** (Pub/Sub API Describe) , ..
- API Documentation
  - `Open API Specification`  - json, yaml 기반의 REST API 문서화 표준
  - `Swagger UI` - OAS 를 Web UI 로 표현 가능하도록 지원

    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/604c1481-ef07-4f33-9bdc-1da2a059425f/802ddf33-fe07-477b-b437-e27b3a9cdc7d/Untitled.png)

    → 라이브러리를 통해 프레임워크의 API 문서 생성 자동화 기능 지원

    → API 명세 및 API TEST 제공을 통해 보기 쉬운 문서 제공

    → API 버전 관리, 통합 API 문서 제공 등의 문서 관리 기능 제공

      ```yaml
      // spring
      implementation("org.springdoc:springdoc-openapi-starter-webmvc-ui:2.0.0")
      
      // nest
      npx nestia swagger
      ```


### 5. Database 지식

**DB Transaction**

- 데이터베이스의 상태를 변화시키기 위한 일련의 작업 단위
- **특징**
  - `Atomicity` ( 원자성 ) - 트랜잭션의 모든 쿼리가 DB 에 반영되거나, 모두 반영되지 않아야 한다.
  - `Consistency` ( 일관성 ) - 트랜잭션의 처리 결과는 항상 일관성 있어야 한다.
  - `Isolation` ( 독립성 ) - 서로 다른 트랜잭션은 서로의 연산에 개입할 수 없다.
  - `Durability` ( 지속성 ) - 트랜잭션이 성공적으로 처리되었다면 그 결과는 영구 반영되어야 한다.
- **주요 기능**
  - `Commit` - DB 의 트랜잭션이 성공적으로 수행되었으며 이를 반영하도록 하는 명령
  - `Rollback` - DB 트랜잭션에서 문제가 발생했을 때, 실행 이전 상태로 되돌리는 명령
- **트랜잭션 격리 수준**
  - **Uncommitted Read** ( 커밋되지 않은 읽기 )
    - 다른 트랜잭션에서 커밋되지 않은 데이터에도 접근할 수 있게 해주는 격리 수준
    - `DirtyRead` - 커밋되지 않은 트랜잭션에 접근해 아직 정상 반영되지 않은 데이터를 읽는 현상( 해당 데이터는 롤백되어 없어질 수도 있다 )
  - **Committed Read** ( 커밋된 읽기 )
    - 다른 트랜잭션에서 커밋된 데이터에만 접근할 수 있게 해주는 격리 수준
    - `Non-Repeatable Read` - 하나의 트랜잭션에서 동일한 SELECT 쿼리를 실행했을 때 커밋 전의 데이터, 커밋 된 후의 데이터가 읽히면서 다른 결과가 조회되는 현상
  - **Repeatable Read** ( 반복 가능한 읽기 )
    - 커밋된 데이터만 읽을 수 있으며, 자신보다 빨리 수행된 트랜잭션에서 커밋한 데이터만 읽을 수 있는 격리 수준
    - **MVCC** 를 통해 Undo 로그를 기반으로 동일한 데이터가 조회되도록 보장 ( Non-Repeatable Read 문제 해결 )
    - 이를 지원하지 않는 DB (e.g. OracleDB ) 에서는 배타 락을 이용해 문제를 해결
    - `Phantom Read` - 하나의 트랜잭션 내에서 동일한 SELECT 쿼리의 결과 레코드 수가 달라지는 현상

        <aside>
        💡 MySQL 에서는 Phantom Read 가 발생하지 않음
        → InnoDB 엔진에 의해 `select ~ for update` 구문을 지원, Next Key Lock 형태의 배타락을 지원하기 때문

        </aside>

  - **Serealizable**
    - 모든 트랜잭션을 순차적으로 실행시키는 격리 수준
    - 트랜잭션이 서로 끼어들 수 있는 상황이 없으므로 데이터의 부정합 문제는 발생하지 않음
    - 위 특성 때문에 트랜잭션이 동기적으로 처리되면서 처리속도 저하가 발생
    - 트랜잭션이 개입하려는 시도 ( e.g. shared Lock 으로 조회 후 Update 하려고 하는 경우 )  대기상태가 되므로 데드락 문제가 발생함

---

**Lock**

- **Shared Lock ( 공유락 )**
  - 데이터를 읽을 때 사용하는 Lock
  - 공유 Lock 끼리는 여러 사용자가 동시에 `읽기` 가 가능
  - 공유 Lock 이 먼저 설정된 데이터에는 배타 Lock 을 사용하는 것이 불가능
- **Exclusive Lock ( 배타락 )**
  - 데이터를 변경할 때 사용하는 Lock
  - 트랜잭션이 완료될 때까지 유지됨 ( e.g. select for update )
  - 배타 Lock 이 적용되어 있다면 다른 트랜잭션은 해당 리소스에 접근하지 못하고 대기
  - 배타 Lock 은 이미 다른 트랜잭션 내에서 사용하고 있는 데이터에 대해 접근해 Lock 을 설정할 수 없음

---

**DB Index**

- 검색 속도 향상을 위해 데이터 ( row ) 를 식별 가능하도록 저장하는 객체 ( e.g. 목차 )
- `검색 속도 향상` 를 통해 `DB 부하 감소` 목적

<aside>
⛔ **주의할 점
*** 인덱스는 저장을 위해 별도의 공간이 필요함 ( 너무 많아도 문제 )
* 인덱스 조정을 위해 데이터의 삽입/수정/삭제 연산 성능이 하락

</aside>

<aside>
❔ 그럼 언제 필요할까?
- 데이터가 너무 많아 조건에 맞게 조회하는 데에 속도가 오래 걸리는 경우
- 인덱스만으로 데이터를 찾을 수 있는 경우

</aside>

**꼭 알아야 하는 Index**

- **`단일 Index`** - 1개 컬럼으로 구성된 Index
- **`복합 Index`** - 여러 컬럼으로 구성된 Index

  → 카디널리티가 높은 컬럼 순으로 구성해 검색 속도를 높일 수 있음

  → 인덱스의 컬럼 순서와 조건의 조회 순서가 일치하지 않는다면 Index 이용 x

- **`Covering Index`** - 특정 쿼리를 충족시키는 데 필요한 모든 데이터를 포함하는 인덱스

  → Table Access 없이 Index Scan 만으로 원하는 데이터를 찾을 수 있음

  → Index Scan 만 발생하므로 높은 조회 성능을 가질 수 있음

  → But 너무 많은 데이터를 포함하거나 인덱스 종류가 많아지면, 그로 인한 성능 저하


---

**DB Table 설계 Tip**

- 테이블은 동일한 위상의 데이터 군집으로 구성한다.
- 적절한 정규화, 반정규화를 통해 데이터를 구성한다. (정규화는 쓰기 성능을 증가시킨다. 반정규화(비정규화) 읽기성능을 증가시킨다.
- 락을 거는 특정 컬럼이 있다면 분리해내어 성능에 영향을 주지 않는 방법도 고려한다.

  e.g. `상품`

  →  `상품 정보`  : 상품을 나타내는 정보들을 하나의 테이블에 응집시킨다.

  →  `상품 옵션`  : 각 상품 옵션은 동일한 상품 정보를 가질 것이므로 상품 정보의 Id 를 통해 연관된 상품 정보를 알 수 있도록 구성한다.

  →  `상품 재고`  : 재고 검증, 차감, 추가 등의 로직을 위해 배타적 Lock 을 이용한다면 상품 정보를 위한 조회에서도 영향을 받을 수도 있으므로 별도로 분리해낸다.


---

### 시나리오를 선택해 서버 애플리케이션 구축

<aside>
❓ 아키텍처와 테스트 코드 작성에 집중하며, 견고하고 유연한 서버 개발이 목표인 사람 (챌린지 과제가 포함되어 있습니다)

<aside>
🚩 **과제 : 이번 챕터 과제**

</aside>

</aside>

[e-커머스 서비스 (1)](https://www.notion.so/e-1-157f5cff9b9281c09ba7f9482dd62919?pvs=21)

[맛집 검색 서비스 (1)](https://www.notion.so/1-157f5cff9b92810b80ebdd597acc41bd?pvs=21)

[콘서트 예약 서비스 (1)](https://www.notion.so/1-157f5cff9b92810395fed914dcbf3e28?pvs=21)

<aside>
🗓️ **Weekly Schedule Summary: 이번 챕터의 주간 일정 (금요일 오전 10시까지 제출)**

</aside>

### **`DEFAULT`**

- 각 시나리오별 하기 **비즈니스 로직** 개발 및 **단위 테스트** 작성
  - `e-commerce` : 상품 조회, 주문/결제 기능
  - `concert` : 대기열 발급, 대기순번 조회, 좌석 예약 기능

> **단위 테스트** 는 반드시 대상 객체/기능 에 대한 의존성만 존재해야 함
>

### **`STEP07`**

- API Swagger 기능 구현 및 캡쳐본 첨부 ( Readme )
- 주요 비즈니스 로직 개발 및 단위 테스트 작성

### **`STEP08`**

- 비즈니스 Usecase 개발 및 통합 테스트 작성

> API 의 완성이 목표가 아닌, 기본 및 주요 기능의 비즈니스 로직 및 유즈케이스는 구현이 완료 되어야 함. ( `Business Layer` )
>

> DB Index , 대용량 처리를 위한 개선 포인트 등은 추후 챕터에서 진행하므로 목표는 `기능 개발의 완료` 로 합니다. 최적화 작업 등을 고려하는 것 보다 모든 기능을 정상적으로 제공할 수 있도록 해주세요. 특정 기능을 왜 이렇게 개발하였는지 합당한 이유와 함께 기능 개발을 진행해주시면 됩니다.
>

### FAQ

- 저는 다른 아키텍처들도 시도해보고 싶은데요 !

  Q : 요즘 Clean , Hexagonal , Vertical Slice 등 다양한 아키텍처에 대한 이야기가 들려옵니다. 이런 것들을 이용해볼 수는 없을까요 ?

  A : 물론 가능합니다 ! 클린 아키텍처는 DDD 기반으로 도메인 중심의 설계에 효율적이며 헥사고날 아키텍처는 보통 잘게 나눈 도메인에 기반한 MSA 에 효율적인 아키텍처입니다. 이는 실제로 SOLID 원칙을 잘 지킨 하에, 레이어드 아키텍처와 함께 녹여내어 현업에서 사용하는 아키텍처입니다. 그래서 러닝커브로 인한 프로젝트의 지연보다는, 우선적으로 기본에 충실한 구현을 진행하고 차후 리팩토링 등을 통해 고도화된 아키텍처의 도입을 시도해보는 것을 추천드립니다.

- TDD 가 아닌 DDD 로 개발하는 것은 안될까요 ?

  A : DDD 와 TDD 는 같은 범주로 묶이는 개발론이 아닙니다. DDD 는 기존 DB 테이블 중심적으로 설계하고, 서비스를 구성하는 방식보다 요구사항에 대해 도메인을 명확히 분석하고, 도메인이 주체가 되도록 기능을 개발하는 방식을 의미합니다. 즉, 설계론적인 의미에서 더 많은 이점을 찾고자 하는 개발론이죠. TDD 는 개발하는 방식을 테스트적인 관점에서 바라보는 방법론입니다. 이에 DDD 로 개발할 때는 각 도메인의 컨텍스트를 보다 명확하게 정의하고, 기능을 단순화하고 정확하게 표현할 수 있어야 합니다.

  A : 위에 설명한 바처럼 오히려 DDD 기반의 설계와 구현에 대해 익숙하고 잘 정의되어 있다면 TDD 방법론을 이용해 개발을 진행하기에 오히려 적합한 구조를 갖출 수 있다고 생각해요. TDD 는 각 기능에 대해 작은 단위로 구성하고 Unit Test 부터 잘 작성해나가며 빠른 주기로 개발/테스트/리팩토링을 반복해나가며 기능을 완성해나가는 방식인데, 도메인이 잘 정의되어 있고 기능에 대한 책임이 명확히 나뉘어져 있다면 더 빠른 개발을 진행할 수 있습니다.

- 위 서비스 3개를 선정한 기준이 어떻게 되나요?

  A : 기존 기수에서는 팀프로젝트에 집중해 규모 있는 시나리오 기반의 큰 프로젝트를 같이 설계하고 테스트 코드, 팀 컨벤션 등 다양한 역량을 기르도록 하는 것이 목표였습니다. 하지만 기능이 다양해지고 많아지다보니 각자가 경험해보고 쌓을 수 있는 역량이 팀원별로 상이해지는 부분들이 있었고, 단순 구현 보다는 이번 챕터에서 백엔드 개발자로서 쌓아야 할 역량에 대한 집중도가 다소 떨어지는 경향을 확인했습니다.

  A : 이에 개개인의 역량 집중 뿐만 아니라, 팀 내에서 서로 다른 생각과 접근 등을 공유하고 피드백할 수 있는 환경을 만들어 더 많은 인사이트를 가져갈 수 있는 방향성으로 시나리오를 전면 재설계 하였습니다.